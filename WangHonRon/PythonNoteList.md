### Python 学习笔记目录
              
#### [1.py系统环境介绍](#1)
#### [2.py语言结构和语法](#2)
   ###### [2.1Python基础](#2.1)
   ###### [2.2高级特性](#2.2)
#### [3.py编程思想](#3)
   ###### [3.1面向对象编程](#3.1)
   ###### [3.2函数式编程](#3.2)
#### [4.py系统编程](#4)
   ###### [4.1IO编程](#4.1)
   ###### [4.2异步IO](#4.2)
   ###### [4.3进程和线程](#4.3)
   ###### [4.4正则表达式](#4.4)
#### [5.py数学与数值计算编程](#5)
#### [6.py用户界面GUI编程](#6)
#### [7.py编码规范和编程模式](#7)
#### [8.pysocket网络和web应用编程](#8)
   ###### [8.1网络编程](#8.1)
   ###### [8.2Web编程](#8.2)
   ###### [8.3电子邮件](#8.3)
#### [9.py数据库编程和管理案例](#9)
   ###### [9.1访问数据库](#9.1) 
#### [10.py数据分析与处理](#10)
#### [11.pyweb实战框架应用](#11)
#### [12.py数据爬虫与采集编程](#12)
#### [13.py数据分析与挖掘编程](#13)
#### [14.py数据可视化编程](#14)
#### [15.py人工智能编程](#15)
#### [16.py运维开发](#16)
#### [17.go语言和区块链编程](#17)


<h3 id='1'>1. 系统环境介绍</h3>

---

1. Python版本区别选择和兼容（Python2.x和Python3.x）  
2. Python安装和开发平台部署，pyenv部署方式及虚拟环境创建配置 
3. Python包管理，pip配置，pip命令使用，pip安装模块
4. Python解释器分类和区别，官方CPython，增强的交互式IPython，使用JIT技术的PyPy，以及虚拟机使用的Jython,IronPython

<h3 id='2'>2. Python语言结构和语法</h3>

---

- 掌握不同数据结构的差异及核心模型
- 掌握核心数据结构基本操作方法
- 掌握常用方法的时间复杂度分析
- 掌握字符串编码、解码和bytes联系
- 掌握内建数据结构原理与操作

1. 变量与常量、数据输出语句、数据输入语句、数据运算与表达式、算数运算、比较运算和逻辑运算；  
2. 位移运算、位算术运算、三目运算、运算符优先级；  
3. type等其他运算符说明；数据类型转换运算；字符串数据结构运算；  
4. 元组tuple数据结构使用、列表list数据结构使用、字典dict数据结构使用、复杂的数据结构使用（如栈、队列、链表）
5. if条件语句、for循环语句、while循环语句；break、continue、return中断与程序中断语句；
6. 可迭代对象、数据解析与生成器、可迭代文件；

<h4 id='2.1'>2.1 Python基础</h4>

> #### 算法和数据结构

- 常见经典算法：
     * 迭代法  
        定义：迭代是函数内某段代码实现循环。  
        区别：1.迭代与普通循环的区别是：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。  2.递归是重复调用函数自身实现循环。  
     * 动态规划法  
        定义：动态规划与分治法相似，都是组合子问题的解来解决原问题的解，与分治法的不同在于：分治法的子问题是相互独立存在的，而动态规划应用于子问题重叠的情况。  
        应用：动态规划方法通常用来求解最优化问题，这类问题可以有很多可行解，每个解都有一个值，找到具有最优值的解称为问题的一个最优解，而不是最优解，可能有多个解都达到最优值。
设计动态规划算法的步骤：
        1. 刻画一个最优解的结构特征
        2. 递归地定义最优解的值
        3. 计算最优解的值，通常采用自底向上的方法
        4. 利用算出的信息构造一个最优解  
        示例：0-1背包问题，钢条切割问题等；
     * 递归与分治法  
        - 递归算法：  
        定义：直接或间接不断调用自身来达到解决问题的方法；  
        要求：原始问题可以分解成相同问题的子问题；  
        示例：阶乘、斐波那契数列、汉诺塔问题等；  
         
        - 分治算法：  
        定义：待解决复杂问题能够简化成若干个小规模相同的问题，然后逐步划分，达到易于解决的程度。  
        要求：1.将原问题分解成n个规模较小的子问题，各子问题间独立存在，并且与原问题形式相同；2.递归的解决各个子问题；3.将各个子问题的解合并到原问题的解；  
        示例：棋盘覆盖、找出伪币、求最值等；       
     
     * 穷举法  
        定义：穷举法的基本思想是根据题目的部分条件确定答案的大致范围，并在此范围内对所有可能的情况逐一验证，直到全部情况验证完毕。  
        
     * 贪婪法  
        定义：贪心算法是就问题而言，选择当下最好的选择，而不从整体最优考虑，通过局部最优希望导致全局最优。  
        贪心算法的要素    
            1）贪心选择性质：可以通过局部最优选择来构造全局最优解。换言之，直接做出在当前问题中看来最优的选择，而不必考虑子问题的解。
            2）最优子结构：一个问题的最优解包含其子问题的最优解。  
        贪心算法的设计步骤：  
            1）将最优化问题转换为这样的形式：对其做出一次选择后，只剩下一个子问题需要求解  
            2）证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的  
            3）证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构。  
        示例：背包问题，均分纸牌，最大整数  
     * 回溯法  
        定义：回溯法是一种搜索算法，从根节点出发，按照深度优先搜索的策略进行搜索，到达某一节点后 ，探索该节点是否包含该问题的解，如果包含则进入下一个节点进行搜索，若是不包含则回溯到父节点选择其他支路进行搜索。  
        回溯法的设计步骤：  
            1）针对所给的原问题，定义问题的解空间  
            2）确定易于搜索的解空间结构  
            3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数除去无效搜索。  
        示例：0-背包问题、旅行商问题、八皇后问题  
     * 分支限界法  
        定义：和回溯法相似，也是一种搜索算法，但回溯法是找出问题的许多解，而分支限界法是找出原问题的一个解。或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。  
        在当前节点（扩展节点）处，先生成其所有的儿子节点（分支），然后再从当前的活节点（当前节点的子节点）表中选择下一个扩展节点。为了有效地选择下一个扩展节点，加速搜索的进程，在每一个活节点处，计算一个函数值（限界），并根据函数值，从当前活节点表中选择一个最有利的节点作为扩展节点，使搜索朝着解空间上有最优解的分支推进，以便尽快地找出一个最优解。
        分支限界法：  
            1）FIFO分支限界法  
            2）优先队列分支限界法：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。  
        示例：装载问题，旅行售货员问题  
     
- 常见数据结构：
     * 数组(Array)    
     `int[] data = new int[100]；data[0]  = 1;`
     下标从0开始，按索引查询元素速度快；按索引遍历方便；
     * 栈(Stack)    
     栈是一种特殊的线性表，仅能在一端操作（栈顶操作）；栈的结构像是集中箱。  
     先进后出，从栈顶放入元素叫入栈，取出元素叫出栈；    
     应用场景：因先进后出，，常用于实现递归功能，如斐波那契数列。    
     * 队列(Queue)  
     队列也是线性表，但可以从一端加元素，从另一段取元素，即先进先出；放入叫入队，取出叫出对；  
     应用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。
     * 链表(Linked List)  
     链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。 
     优点：链表是很常用的一种数据结构，不需要初始容量，可以任意加减元素，只需改变前后两个元素节点的指针域指向地址即可，所以增加、删除很快。  
     缺点：因为占用大量指针域，占用空间较大。 查找是遍历链表，非常耗时；  
     使用场景：数据量较小，需要频繁增加、删除的场景；   
     * 树(Tree)  
     树也是一种数据结构，由n(n>=1)个有限节点组成一个具有层次关系的集合。  
     叫做树，是因为看起来像是一个倒挂的树。特点如下：    
         - 每个节点有零个或多个子节点；
         - 没有父节点的节点称为根节点；
         - 每一个非根节点有且只有一个父节点；
         - 除了根节点外，每个子节点可以分为多个不相交的子树；    
     日常中，用的更多的是二叉树结构，特点如下：  
         - 每个节点最多有两颗子树，节点的度最多2个；
         - 左子树和右子树是有顺序的，次序不能颠倒；
         - 即使某个节点只有一个子树，也要区分左右子树。  
     二叉树优点：它是一种比较折中的方案，增加、删除元素很快，且在查找方面也有很多算法优化，所以二叉树既有链表的好处，也有数组的好处，在处理大批量的动态数据方面非常有用。  
     二叉树扩展：如`平衡二叉树、红黑树、B+树`等，如MySQL的数据库索引结构用的是B+树、HashMap的底层原码中用到了红黑树。  
     * 散列表(Hash)    
     散列表也叫哈希表，是根据键值对（key和value）直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就很快找到集合中对应的元素。  
     对应的关系fn称为散列函数，又称哈希（即`哈希函数`）：  
     哈希原理：它是把key通过哈希函数fn(key)转换成一个整型数字，然后将该数字对数组长度取余，取余结果当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以速度很快。  
     哈希表应用：有些集合类就是借鉴了哈希原理构造的，如HashMap、HashTable等。利用hash表的优势，在集合中查找元素非常方便。  
     缺点：由于哈希表是基于数据衍生的数据结构，在添加删除元素是比较慢的，需要一种数组链表来做，也就是`拉链法`
     * 堆(Heap)  
     堆是一种特殊的数据结构，可以被看做是一棵树的数组对象，具有如下性质：
         - 堆中某个节点的值总是不大于或不小于其父节点的值；
         - 堆总是一颗完全二叉树；  
     将根节点最大的堆叫最大堆或大根堆或大顶堆；根节点最小的堆叫最小堆或小根堆或小顶堆；常见的堆有二叉堆、斐波那契堆；  
     应用场景：因为堆有序的特点，一般用来做数组中的排序，称为堆排序；  
     * 图(Graph)    
     图是由节点的有穷结合V和边的集合E组成。其中为了和树结构区分，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。  
     分类：按顶点的指向的方向，可分为无向图，和有向图；  
     图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵、邻接表、十字链表、邻接多重表、边集数组等存储结构。

> #### 数据类型和变量

   - pythony常见数据结构：
     * 列表(list)  
     * 元组(tuple)  
     * 字典(dict)  
     * 集合(set) 
     * 字符串(str)
     * 整型(int) 
   - 变量  
     变量：赋值即定义、无需声明类型
          

> #### 字符串和编码
    - 字符串方法(String Methods)
  
  ```python
>>>str.capitalize() #return a copy of the string with its first character capitalized and the rest lowercased. 
>>>str.casefold()
>>>str.center(width=5,fillchar='*')
>>>str.count()
>>>str.encode(encoding='utf8', errors='strict')

```

> #### 使用list和tuple

> #### 条件判断

> #### 循环

> #### 使用dict和set

<h4 id='2.2'>2.2 高级特性</h4>

> #### 切片

> #### 迭代

> #### 列表生成式

> #### 生成器

> #### 迭代器

<h3 id='3'>3. Python编程思想</h3>

---

- 类封装与运用方法、类方法
- 掌握类继承
- 掌握属性装饰器的应用
- 实例属性访问机制和访问顺序
- 常用魔术方法运用

1. 函数基本概念、形参、实参、位置参数、关键字参数、参数默认值；

2. 函数的可变位置参数、可变关键字参数、keyword-only参数；位置传参、关键字传参、参数结构；

3. 函数return语句及返回值、嵌套函数、函数作用域、global、闭包、nonlocal;

4. 参数缺省值的常见问题处理办法和__default__；LEGB原理；

5. 函数执行流程及调用原理、递归函数概念和递归性能分析、匿名函数lambda表达式概念及应用；

6. 面向对象的分析与设计OOA&D；面向对象编程OOP；类的实现语法；类的成员数据描述；类的成员方法声明与定义；

7. __init__.py文件、Python包格式、管理工具和程序打包分发Python动态模块加载技术和插件化开发；

8. 扩展内置类型、新式类、新式类的扩展、静态方法、函数装饰器、元类模型、面向对象分析设计；

<h4 id='3.1'>3.1 面向对象编程</h4>

> #### 类和实例

##### 单例类

单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。

- 应用场景：
    1. 需要频繁进行创建和销毁的对象；
    2. 创建对象时消耗资源过多或消耗时间过多，但又经常用到的对象；
    3. 工具类对象；
    4. 频繁访问数据库或文件的对象；

- 实现思路：

    1. 将该类的方法定义为私有方法；
    2. 在该类内定义静态方法；
    
- 实现代码：

```python
class Singleton:
    _instance = None
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super.__new__(cls, *args, **kwargs)
            return  cls._instance
```

> #### 访问限制

- 私有变量

在Python中，实例变量名如果以头`__name__`，就变成了一个私有变量（private）,只有内部可以访问，外部不能访问。如果外部要访问，请给实例增加get方法。
例外，如`_name`单下划线开头，可以被外部访问，但按约定不要随意访问。
_python本身没有任何机制阻止我们干坏事，一切靠自觉_

```python
class Student:
    def __init__(self, name, score):
        self.__name = name
        self.__score = score
        
    def get_name(self):
        return self.__name
    def get_score(self):
        return self.__score
    def set_score(self, score):
        self.__score = score        
```

- 特殊变量

在Python中，变量名以`__xxx__`双下划线开头和结尾命名的，是特殊变量，可以直接访问的，不是private变量

> #### 集成和多态

> #### 获取对象信息

> #### 实例属性和类属性

- 属性定义：

    * 实例属性：声明在方法中，通过self声明的属性，是实例对象所特有的属性，而实例对象是类创建的对象。实例属性是在`__init__`方法中定义的属性，self是指向实例自己，类似Java中的this关键字，实际是通过内置的方法`setattr()`完成的。
    * 类属性：声明在类内部，方法外部的属性。是定义类时候直接定义的属性，类似Java中static修饰的属性，可直接通过类名访问。
    _当类属性和实例属性同名时，一个实例访问这个属性时实例属性会覆盖类属性，但类访问时不会_

- 属性访问顺序
`实例调用__getattribute__() --> instance.__dict__-->instance.__class__.__dict__-->继承祖先类的__dict__ --> __getattr__()`
- 举例

```python
class People():
    name = 'jerry' # 公有的类属性
    __age = 18 # 私有的类属性
    
    def __init__(self, name, age):
        self.name = name # 实例属性
        self.__age = age # 实例属性
        
p = People('tom',21)
p.name # tom
People.name # jerry
```
- #### 面向对象高级

> #### 使用__slots__

应用场景：动态给实例绑定属性时，如果我们想要限制实例的属性怎么办？比如，只允许对Person实例添加name和age属性，为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性。  

```python
class Person():
    __slots__ = ('name','age')
    
psn = Person()
psn.name = 'jeck'
psn.age = 28
# psn.sex = '男'# 报错，
# 以上实例不能绑定sex属性，因为在__slots__中没有定义
# 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的；除非在子类额定义__slots__属性；
```

> #### 使用@property

应用场景：@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。  

```python
import datetime
class Student(object):
  
    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        nowYear =datetime.datetime.now()
        return nowYear - self._birth
        
    # 以上‘birth’属性可读写、‘age’属性只读
```

> #### 多重继承

定义：类通过继承，子类可以扩展父类的功能。  

```python
class Runnable(object):
    def run(self):
        pass

class Flyable(object):
    def fly(self):
        pass
        
class Animal(object):
    # 动物父类
    pass

# 大类:
class Mammal(Animal):
    # 动物子类—哺乳动物类
    pass

class Bird(Animal):
    # 动物子类—鸟类（有翅膀，孵化哺育下一代）
    pass

# 各种动物:
class Dog(Mammal, Runnable):
    # 狗
    pass

class Bat(Mammal, Flyable):
    # 蝙蝠
    pass

class Parrot(Bird, Flyable):
    # 鹦鹉
    pass

class Ostrich(Bird, Runnable):
    # 鸵鸟
    pass
```

#### 多重继承-MixIn类  

   定义：类混合继承时，通常是单一继承下来，如果需要混入额外功能时，通过多重继承实现，这种设计通常称之为MinIn。  
   应用：为了更好的看出继承关系，如上例子，我们把`Runnable`改为`RunnableMinIn`,让某个动物同时拥有几个MixIn。  
   目的：给一个类增加多个功能，在设计时候优先通过多重继承来组合多个MinIn功能，而不是设计多层的复杂继承关系。  
   例子：如Python自带的`TCPServer`和`UDPServer`网络服务，同时服务多个用户就必须使用多进程和多线程，  
   这模型由ForkingMinIn和ThreadingMinIn提供，通过组合创造出合适的服务。  
 ```python
from socketserver import TCPServer, ForkingMixIn

class MyTCPServer(TCPServer, ForkingMixIn):    
    pass
```
   
> #### 定制类

   定义：Python的class中有很多特殊用途的函数，可以帮助我们定制类，如`__slots__`等形如`__xxx__`;   
    
   函数|定义|语法
   --|--|--
   `__str__`|返回字符串格式|返回用户看到的字符串格式
   `__repr__`|返回字符串格式|返回程序开发者看到的字符串格式
   `__iter__`|返回可迭代对象|惰性的，需调用可迭代对象的`__next__`拿到下一个值
   `__getitem__`|返回像list的元素|可通过下表需元素
   `__getattr__`|调用不到属性时，动态返回一个属性值|只有在没找到属性情况下，才调用`__getattr__`
   `__call__`|可以直接对实例进行调用|可以把对象看成函数，把函数看成对象
   
   

> #### 使用枚举类

> #### 使用元类

<h4 id='3.2'>3.2 函数式编程</h4>

> #### 高阶函数

> #### 返回函数

> #### 匿名函数

> #### 装饰器

> #### 偏函数

<h3 id='4'>4. Python系统编程</h3>

---

- 掌握文本读写操作，路径操作和高级文件操作
- 掌握Json、msgpack序列化库
- 掌握正则表达式并对文本处理
- 掌握网络间数据通信
- 掌握程序设计中处理并发

1. 异常的工作机制、异常语法、Python异常类结构、捕捉异常、抛出和转移异常；

2. try/except/else理解与使用、try/finally理解与使用、with语句及其异常域内存管理机制；

3. 程序的内存结构理解、Python变量与对象的内存存储理解、内存的引用于技术；

4. Python的垃圾回收、Python的内存池与虚拟机管理机制、标准解释器类型；

5. 文件打开与文件描述符、文件的编码与Unicode、二进制文件与文本文件、顺序文件与随机文件；

6. 理解进程与线程、创建进程、僵尸进程与孤儿进程；创建多线程、控制线程、线程的属性；

7. 信号量通信semaphore；事件通信event；队列通信queue；管道通pipe；进程池pool；

<h4 id='4.1'>4.1 IO编程</h4>

> #### 文件读写

> #### StringIO和BytesIO

> #### 操作文件和目录

> #### 序列化

<h4 id='4.2'>4.2 异步IO</h4>

> #### 协程

> #### asyncio

> #### async/await

> #### aiohttp

<h4 id='4.3'>4.3 进程和线程</h4>

> #### 多进程

> #### 多线程

> #### threadlocal

> #### 进程 VS 线程

> #### 分布式进程

<h4 id='4.4'>4.4 正则表达式</h4>

<h3 id='5'>5. Python数学与数值计算编程</h3>

---

- 掌握常见算法和数据结构
- 常见数学函数编程实现
- 掌握数学数值可视化

1. 数据结构与算法应用场景介绍、算法分析、数据结构性能；

2. 链表、列表数据结构、栈数据结构、队列数据结构；

3. 排序算法、搜索算法、树数据结构、树算法、 图数据结构、图算法；


<h3 id='6'>6. Python用户界面GUI编程</h3>

---

- 掌握tkinter基础编程
- 掌握Kivy框架和图像处理
- 掌握PyQt框架实现游戏界面

1. tkinter的历史与模块；tkinter编程模式；tkinter属性与配置模式；

2. tkinter窗体容器实现；tkinter常见按钮，文本、标签、下拉等组件应用；

3. tkinter事件交互处理、定制图形绘制实现；

4. Kivy框架模块结构、Kivy应用App程序、Kivy Wiget与组件、Kivy布局、Kivy事件处理、Kivy按钮、文本等创建组件使用、图形绘制模式、基本图形绘制、图形处理；

5. PYQt框架结构、 PyQt编程模式、使用PyQt创建窗口、组件使用、布局使用、信号与槽机制、定制图形绘制；

<h3 id='7'>7. Python编码规范和编程模式</h3>

---

- 掌握BAT一线企业代码命名和设计规范
- 掌握企业编程架构构建模式
- 实现业务系统架构设计

1. 包命名规范、模块命名规范、类命名规范、函数命名规范、变量和常量命名规范、注释规范、块编码规范、PEP8规范；

2. 文件头和模块注释、类注释、函数注释；

3. 构建模式-单子模式；构建模式-工厂模式；结构模式-Adapter Class/object(适配器)、结构模式-Composite(组合)、结构模式-Decorator(装饰)、结构模式-Facade（外观）、 结构模式-Proxy（代理）

4. 行为模式-Interpreter（解释器）、行为模式-Iterator（迭代器）、行为模式-Mediator（中介者）、行为模式-Observer（观察者）、行为模式-Visitor（访问者）

<h3 id='8'>8. soket网络和web应用编程</h3>

---

- 掌握网络协议核心知识点
- 理解不同协议编程模式
- 理解IO模型
- 掌握同步、异步编程的差异
- 掌握socket基本编程模式
- 掌握网络基本原理，掌握TCP、http核心知识

1. 网络编程相关指令；IP地址分类和用途；IP地址操作编程；

2. socket编程模式；socket TCP编程模式；socket UDP编程模式； 数据包拦截实现；port端口的用途和操作编程；

3. ICMP，UDP，TCP 数据包解析；TCP通讯握手协议；IP数据包解析；ARP数据包解析；定制IP数据包；定制ARP数据包；网际校验方法；端口描述实现；

4. http协议介绍；http请求数据包说明与定制构建；http常见请求头说明；http常见请求方法说明与应用；http响应数据包说明与定制构建；http常见响应头说明；

<h4 id='8.1'>8.1 网络编程</h4>

> #### TCP编程

> #### UDP编程 

<h4 id='8.2'>8.2 Web编程</h4>

> #### HTTP协议和HTML简介
web应用中，服务器把网页传给浏览器，实际上是把网页的HTML代码发送给浏览器，让浏览器显示出来，而浏览器和服务器之间的传输协议是HTTP。  
- HTML是一种用来定义网页的文本，会HTML，就可以编写网页;  
- HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信;  

> HTTP

HTTP请求：  
1. 浏览器首先给服务器发送HTTP请求，请求包括：  
    - 方法：GET、POST  
    - 路径：/full/url/path
    - 域名：有HOST头指定  
    以及相关Header  
2. 服务器向浏览器返回HTTP响应，响应包括：  
    - 响应代码：200成功、300重定向、400客户端请求出错、500服务端处理出错  
    - 响应类型：由content-type指定  
    以及相关的Header；通常HTTP响应会携带内容，即body内容  
3.   
      
HTTP格式：每个HTTP请求和响应都遵循形同的格式，一个HTTP包含Header和Body两部分，其中body可选。  
HTTP协议是一种文本协议，格式很简单，如下：

```python
# HTTP GET请求格式
GET /path HTTP/1.1
Header1:value1
...
# HTTP POST请求格式
POST /path HTTP/1.1
Header1:value1
...
#HTTP 响应格式
200 OK
Header1:value1
...
```

> HTML


> #### WSGI接口

> #### Web框架

 ##### Web 模板（template）
> jinjia2 基于python的模板引擎，设计思路来自Django模板引擎
> 官网文档： http://jinja.pocoo.org/

```
# 安装
> pip install jinjia2
> pip install Markupsafe
```

> code implement

```
# new yourapplication package,new file of python for templates
from jinja2 import Environment, PackageLoader, select_autoescape
env = Environment(
    loader=PackageLoader('yourapplication', 'templates'),
    autoescape=select_autoescape(['html', 'xml'])
)
dit = {
    'userlist':[
        (1,'zhangsan',29),
        (2,'lisi',23),
        (3,'wangwu',25)
    ]
}
template = env.get_template('mytemplate.html')
print(template.render(**dit) # render(the='variables', go='here')

# new mytemplate.html in yourapplication
<!DOCTYPE HTML>
<html>
 <body>
  <ul>
    <% for id,name,age in userlist>
    <li>{{loop.index}},{{id}},{{name}},{{age}}</li>
    <% endfor %>
 </body>
</html>
```
 #### React界面框架

- React 起源于 Facebook 的内部项目，在2013年5月开源。
- React 是一个采用声明式，高效而且灵活的用来构建用户界面的框架
- React主要用于构建UI，可以在React里传递多种类型的参数，如声明代码，帮助你渲染出UI、也可以是静态的HTML DOM元素、也可以传递动态变量、甚至是可交互的应用组件。
    - *使用React前必须熟悉HTML和JavaScript*
    - *熟悉ES6最新版本的 JavaScript,主要使用 arrow functions, classes, let, and const 几个新的语法和关键字*
- React开发环境搭建
1. 安装最新版Node.js
2. 创建新的React项目
3. 删除掉生成项目中 src/ 文件夹下的所有文件
4. 在 src/ 文件夹下新建一个名为 index.css 的文件
5. 在 src/ 文件夹下新建一个名为 index.js 的文件，并在此文件的最开头加上下面几行代码
```
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
```

   - *接下来通过命令行在你的项目目录下运行 npm start 命令,并在浏览器中打开 http://localhost:3000 就能够看到HTML网页*
- 使用技巧
    * JSX， 一种 JavaScript 的语法扩展。 我们推荐在 React 中使用 JSX 来描述用户界面。JSX 乍看起来可能比较像是模版语言，但事实上它完全是在 JavaScript 内部实现的。  
    * Babel 转译器会把 JSX 转换成一个名为 React.createElement() 的方法调用。
    * 元素渲染
    * 组件&Props
    * state&生命周期
    * 事件处理
    * 条件渲染
    * 列表&keys
    * 表单
    * 状态提升
    * 组合继承
    * React理念
#### DjangoWeb框架

Django 项目是一个Python定制框架，它源自一个在线新闻 Web 站点，于 2005 年以开源的形式被释放出来，Django遵守BSD版权，初次发布于2005年7月, 并于2008年9月发布了第一个正式版本1.0。Django 框架的核心组件有：
1. 用于创建模型的对象关系映射
2. 为最终用户设计的完美管理界面
3. 一流的 URL 设计
4. 设计者友好的模板语言
5. 缓存系统  
Django是一个基于MVC构造的框架。但是在Django中，控制器接受用户输入的部分由框架自行处理，所以 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），称为 MTV模式

|模式|层次|职责|
|::|::|::|
|Model|数据存取层|处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等|
|Template|数据表现层|处理与表现相关的决定： 如何在页面或其他类型文档中进行显示|
|view|业务逻辑层|存取模型及调取恰当模板的相关逻辑。模型与模板的桥梁|

Django基于MVC的设计十分优美：

    * 对象关系映射：定义自己的数据模型，
    * URL分派：使用正则表达式匹配URL
    * 模板系统：使用Django强大可扩展的模板语言，如分隔设计、内容和代码，且具有可继承行。
    * 表单处理：可生成各种表达模型，实现表单的有效性检验。
    * Cache系统：可挂在内存缓冲或其他框架实现超级缓冲。
    * 会话（Session）：用户登录与权限检查，快速开发用户会话功能。
    * 国际化：内置国际化系统，方便开发出多种语言的网站。
    * 自动化的管理界面：自带ADMIN site管理人员和更新内容。




<h4 id='8.3'>8.3 电子邮件</h4>

> #### SMTP发送邮件

> #### POP3收取邮件 

<h3 id='9'>9. 数据库编程与管理案例</h3>

---

- 掌握数据库DML使用
- 掌握多表关系：一对一、一对多、多对多
- 掌握ORM库的使用，尤其对多表间关系的操作

1. MySQL数据库安装；MySQL服务器配置与客户端配置；MySQL编码设置；MySQL环境变量查看与修改；MySQL启动与关闭；

2. MySQL客户端远程登录与使用；MySQL数据库切换、查看库、查看表等常见操作指令；

3. 关系数据库基础；数据库三大范式和增强范式；MySQL数据库内置数据库类型与用户数据类型；DDL数据库与定义语句；字段表级约束字段级约束；DML数据表操作语句；DQL数据查询基本语句；DTL数据事物管理语句；多表关联select查询；


##### database三大范式
范式|内容
--|--
第一范式|1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；
第二范式|2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；
第三范式|3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余


##### sql语言
语言|内容
--|--
DDL数据定义语言|数据库和对象定义，由create、alter、drop组成
DML数据操作语言|数据库对象操作，由CRUD增删改查组成
DCL数据控制语言|数据库权限访问控制，由grant、revoke组成
TCL事务控制语言|处理ACID事务，支持commit、rollback指令

4. 数据库单行、聚合、字符串、日期、统计等常见函数使用；索引；序列对象视图；存储过程与调用；SQL脚本编程基础；

5. PyMySQL模块结构；MySQL数据库连接；MySQL游标操作；MySQL数据集查询；MySQL数据记录访问与遍历；

6. MySQL数据字段访问操作；MySQL元数据访问；MySQL数据库数据操作实现；MySQL事务提交与回滚操作；数据错误处理；


<h4 id='9.1'>9.1 访问数据库</h4>

> #### 使用SQLite

> #### 使用MySQL

> #### 使用SQLAlchemy

<h3 id='10'>10. Python数据分析与处理</h3>

---

- 对上证指数A50股票数据进行格式化
- 对淘宝商户数据进行JSON转存
- 用正则表达式进行用户网站IP过滤
- 根据项目中数据格式，进行数据转换

1. XML基本语法；编写结构良好的XML；DTD介绍；XSD介绍；

2. XML SAX事件访问模型；XML DOM访问模型；读写XML文件；

3. XPATH基本语法；XPATH节点定位；XPATH运算符号；使用XPATH遍历XML文档；

4. JSON转换为Python数据类型；把Python数据类型转换为JSON字符串；

5. 正则表达式基本语法；正则表达式元字符；正则表达式运算优先级；正则表达式匹配规则；match匹配；匹配对象使用；匹配标志；search匹配；

6. findall正则表达式查找；finditer正则表达式查找；split正则表达式切割；

7. 正则表达式在输入校验中的使用；正在表达式在文本解析中的使用；

<h3 id='11'>11. web实战框架应用</h3>

---

- 开发常见web网站的前端页面和移动端H5页面
- 跟后台进行数据通信
- 掌握市场流行的前后端分离开发模式中应用的前端react框架
- 高并发全功能web网站开发、提供数据响应速度灵活运用缓存
- 根据实际问题设计出相应数据库表，可根据业务流程图开发web网站后台业务
- 根据web框架设计，开发对应数据库和web接口设计
- 通过完整前后端分离项目，掌握Django核心技术

1. 掌握常用web框架：Django、flask、Tornado等；

2. 掌握企业前后端开发、数据库开发、前端react框架开发；

3. 可实现大型互联网Python网站开发架构和项目实战；

4. 使用Django模板实现多种数据格式输出；前后端分离多人博客项目；京东商场交易后台系统；类知乎问答系统；仿豆瓣在线评论系统

<h3 id='12'>12. Python数据爬虫与采集编程</h3>

---

- 掌握分布式爬虫和数据采集系统的分析和设计技巧
- 掌握多平台相关信息的抓取分析
- 掌握高性能爬虫系统的开发技巧
- 掌握大规模数据的爬取、解构、去重、分类、垃圾过滤、质量识别等能力
- 掌握实时监控爬虫的进度和报警信息处理
- 掌握内容提取、处理、结构化、过滤等数据处理，并设计存储结构，常用爬虫框架与平台使用（Scrapy等）
- 掌握各种爬虫工具与框架，掌握各种反爬虫技术、并能破解

1. 掌握常用web框架：Django、flask、Tornado等；

2. 掌握企业前后端开发、数据库开发、前端react框架开发；

3. 可实现大型互联网Python网站开发架构和项目实战；

4. 微信数据采集系统；气象与农产品数据爬取系统；在线实时翻译系统；基于知乎的新媒体销售运营辅助系统；常见反爬虫技术实战；

<h3 id='13'>13. Python数据分析与挖掘编程</h3>

---

- 掌握数据挖掘相关算法：包括决策树、SVM、聚类、逻辑回归等
- 掌握数据分析、挖掘、清洗和建模技巧
- 掌握Spark、Hadoop、Hive、Storm的搭建部署与使用
- 掌握常见数据分析与挖掘的应用；用户行为的挖掘、用户画像、用户行为分析、推荐、反作弊等；
- 掌握ETL流程与技巧
- 理解数据挖掘模型及预测分析结果，能撰写相关分析报告

1. Numpy计算框架与矩阵运算编程；Matplotlib可视化编程；Scipy数值计算编程；Pandas与数据基础分析；数据清洗原则与技巧；

2. 机器学习算法与应用编程；sklearn框架应用编程；商业数据职能分析与挖掘；

3. Hadoop与Spark大数据平台；推荐系统实战；预测系统实战；数据清洗实战；

<h3 id='14'>14. Python数据可视化编程</h3>

---

- 熟悉各前端技术，熟悉主流前端框架
- 能独立编写结构清晰、逻辑严谨的可视化模块化
- 能对各企业商业与运营数据提出专业的数据可视化方案
- 解决各浏览器兼容性问题
- 通过各前端技术手段提高用户可视化体验并满足性能
- 对各大数据平台设计数据分析应用的架构实现实时数据调用与展示
- 能熟练应用各种数据可视化元素

1. SVG与WebGL编程；D3与Tree数据可视化框架开发（Echart等）

2. 企业商业数据可视化技巧编程；

3. 大数据可视化实战；企业大屏可视化实战；

<h3 id='15'>15. Python人工智能编程</h3>

---

- 体验每种算法的应用背景
- 掌握人工智能算法：神经网络、逻辑回归、决策树、贝叶斯等
- 使用tersorflow完成人工智能核心代码编写
- 熟悉深度学习相关算法，累积基于深度学习的目标分类、目标检测、  自然语言处理
- 强化对算法的研究、改进和应用
- 相关算法在非结构化数据处理等领域的应用
- 掌握智能学习平台的选型、框架搭建、开发及优化

1. OpenCV图像处理与音视频采集；

2. 深度学习（深度神经网络）应用编程。前馈神经网络；卷积神经网络；循环神经网络；递归神经网络；人工智能特征选择与参数调优编程；

3. Tensorflow人工智能编程；TensorFlow线性运算；TensorFlow图像处理；TensorFlowNN模块；TensorFlow训练模块；TensorFlow神经网络实现；TensorFlow人脸识别实现；

4. 人脸图像识别实战；语音识别实战；自然语言实战；

<h3 id='16'>16. Python运维开发</h3>

---

- 运维工具的熟悉、学会YAML语言和SSH编程
- 编写通信模块，掌握zerorpc通信机制
- 掌握Zookeeper原理，学习掌握kazoo库的使用及应用
- 使用建模工具，从头构建数据关系模型，理解范式和反范式
- 熟悉对业务的分析、提炼、设计和实现
- 掌握web框架flask，实现CMDB资产管理系统、堡垒机系统、任务调度系统

1. 掌握RPC通信与开发；

2. 学会分层；模块化开发；面向对象封装进阶；

3. 了解主从模型解决方案与实现；

4. 数据库关系模型设计；

5. 单例模式实现；flask微框架开发应用；

6. 任务调度系统；任务流程系统；

7. CMDB资产管理；jumpServer

<h3 id='17'>17. Python数据爬虫与采集编程</h3>

---

- 掌握一门区块链开发语言Go或者Python或者web3
- 能使用solidity编写智能合约
- 能搭建私有区块链平台
- 掌握区块链的基本管理指令

1. 以太坊私有区块链搭建、使用与管理；以太坊区块链安装与部署；以太坊基本指令；挖矿；数字钱包操作；

2. Solidity智能合约编程；solidity数据类型；solidity函数；合约；合约编译；合约部署；

3. Python区块链应用编程；Python块定义；区块链定义；区块链交易信息描述；Python挖矿实现；区块链工作量证明；

4. Go语言编程与区块链应用；Go语言结构；Go数据与变量；Go数据运算；Go控制语句；Go函数；Go面向对象b编程；Go异常处理；Go区块链包；使用Go实现块生成；使用Go实现散列计算；使用Go实现块校验；使用Go实现智能合约调用；

5. 智能合约实战；区块链应用开发实战；DApp开发实战；

##### 难点记录
- 滑动窗口
- 生产者、消费者开发模式
- 异步开发模式
